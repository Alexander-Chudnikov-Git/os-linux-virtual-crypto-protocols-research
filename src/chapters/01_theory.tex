\section{Теоретическая часть}

\subsection{Основные понятия}

В названии дипломной работы присутствует термин "виртуальный криптографический сетевой интерфейс", который является составным.
Это означает, что для того что бы дать ему определение, в первую очередь тредуется определить три ключевых понятия, из которых он состоит:
\begin{itemize}
    \item Криптографическое средство защиты информации: (СКЗИ)
    \item Виртуальная частная сеть (VPN)
    \item Виртуальный сетевой интерфейс
\end{itemize}

\subsubsection{Средство криптографической защиты информации}
В соответствии с ГОСТ Р 50922-2006 "Защита информации. Основные термины и определения", под средством криптографической защиты информации (СКЗИ) понимается: <<Средство защиты информации, реализующее алгоритмы криптографического преобразования информации>>~\cite[с. 4]{gost_50922_2006}.\\

Если говорить более развернуто, то СКЗИ можно назвать набором аппаратных, программных или программно-аппаратных средств, обеспечивающих одну из следующих функций~\cite[с. 1]{pp313}:
\begin{itemize}
    \item Шифрование и расшифрование данных
    \item Вычисление имитовставки
    \item Изготовление ключевых документов
    \item Формирование и проверка электронной подписи
    \item Кодирование и декодирование данных
\end{itemize}

\subsubsection{Виртуальная частная сеть}
Понятие виртуальной частной сети определяется в ГОСТ IEC 60050-732-2017 "Международный электротехнический словарь. Часть 732. Технологии компьютерных сетей".
Согласно этому стандарту, <<виртуальная частная сеть (VPN) — это компьютерная сеть, в которой для передачи данных используют промежуточные сети (например, Интернет), прозрачные для пользователей и не вводящие ограничения на протоколы, в результате чего сеть функционирует как локальная компьютерная сеть>>~\cite[с. 2]{gost_60050_732_2017}.
Примечание к стандарту указывает, что при передаче данных обычно используется туннелирование.\\

Однако, если говорить про VPN в контексте информационной безопасности данное определение следует дополнить.
Основной задачей VPN является не просто объединение сетей, а также обеспечение защищенного обмена информацией между ними.
Фактически, VPN выступает в роли виртуальной сети, которая создает защищенный канал (туннель) между участниками такого обмена.\\

Таким образом, более подходящим определением для VPN будет являться:
VPN - обобщённое название технологий, позволяющих обеспечить одно или несколько сетевых соединений поверх другой сети (как правило, публичной), требующая аутентификации клиентов и использующая шифрование для обеспечения конфиденциальности и целостности передаваемых данных.\\

В зависимости от применяемых протоколов и назначения, VPN можно разделить на три вида:
\begin{itemize}
    \item \textbf{Узел-узел (Host-to-Host)}:
    Данный тип соединения устанавливает защищенный туннель между двумя отдельными компьютерами в сети.
    Такой тип соединения позволяет обеспечить зашифрованный обмен информацией в рамках недоверенной сетевой среды, ограничивая при этом доступ только участвующим в обмене компьютерам.
    \item \textbf{Узел-сеть (Remote Access VPN)}:
    Этот тип соединения предназначен для обеспечения безопасного удаленного доступа.
    Он позволяет отдельным пользователям, находящимся вне корпоративной сети, безопасно подключаться к ресурсам компании используя при этом публичные сети.
    \item \textbf{Сеть-сеть (Site-to-Site VPN)}:
    Последний тип VPN используется для безопасного объединения нескольких территориально распределенных локальных сетей в единую корпоративную сеть через Интернет.
    VPN-шлюзы, установленные на границе каждой из локальных сетей, создают между собой постоянный зашифрованный туннель, через который проходит весь трафик.
\end{itemize}

\subsubsection{Сетевой адаптер}
Сетевой адаптер — это физическое аппаратное устройство, которое обеспечивает непосредственное подключение компьютера к сетевой среде.

\subsubsection{Cетевой интерфейс}
Сетевой интерфейс — это логическая сущность в ядре операционной системы. Именно интерфейс является точкой, которой присваивается IP-адрес и через которую приложения отправляют и получают сетевые пакеты.
\input{src/embeds/tikz/00_network_interface}

\subsubsection{Виртуальный сетевой интерфейс}
Прямое определение термина "виртуальный сетевой интерфейс" в ГОСТах, посвященных защите информации, отсутствует, так как это базовое понятие из области сетевых технологий.
Однако его суть можно описать, опираясь на общую техническую документацию.\\

Виртуальный сетевой интерфейс — это программный компонент, который эмулирует работу физического сетевого адаптера (сетевой карты).
В отличие от физического интерфейса, который представляет собой аппаратное устройство, подключаемое к сети, виртуальный интерфейс существует исключительно на программном уровне.
Он обладает всеми атрибутами реального интерфейса: ему можно присвоить IP-адрес, MAC-адрес, настроить маршрутизацию и правила брандмауэра.
Операционная система и приложения взаимодействуют с виртуальным интерфейсом так же, как и с физическим.

\subsubsection{Виртуальный криптографический сетевой интерфейс}
Исходя из трех вышеописанных понятий, можно сформулировать комплексное определение.\\

Виртуальный криптографический сетевой интерфейс — это виртуальный сетевой интерфейс, который на программном уровне реализует функции средства криптографической защиты информации для обеспечения безопасной передачи данных, как правило, в рамках виртуальной частной сети (VPN).

\subsubsection{Эталонная модель взаимодействия открытых систем}
Эталонная модель OSI (Open Systems Interconnection) — это концептуальная семиуровневая структура, разработанная Международной организацией по стандартизации (ISO)~\cite[c. 28]{iso_7498_1} для унификации понимания сетевых функций.
Она описывает, какие задачи должен выполнять каждый этап сетевого взаимодействия, от физической передачи битов до работы с приложениями.\\

Семь уровней модели OSI:
\begin{itemize}
    \item \textbf{Прикладной уровень (Application Layer)}: Предоставляет сетевые службы непосредственно пользовательским приложениям (например, HTTP, FTP).
    \item \textbf{Представления уровень (Presentation Layer)}: Отвечает за преобразование, шифрование и сжатие данных, обеспечивая их понятный для приложений формат.
    \item \textbf{Сеансовый уровень (Session Layer)}: Устанавливает, управляет и завершает сеансы связи между приложениями.
    \item \textbf{Транспортный уровень (Transport Layer)}: Обеспечивает надежную сквозную доставку данных между конечными устройствами (протоколы TCP, UDP).
    \item \textbf{Сетевой уровень (Network Layer)}: Определяет путь для доставки пакетов данных через одну или несколько сетей, используя логическую адресацию (IP-адреса).
    \item \textbf{Канальный уровень (Data Link Layer)}: Организует передачу данных в виде кадров между двумя непосредственно подключенными узлами, используя физическую адресацию (MAC-адреса).
    \item \textbf{Физический уровень (Physical Layer)}: Отвечает за передачу битового потока по физической среде передачи (кабели, радиоэфир).
\end{itemize}

\input{src/embeds/tikz/01_osi_model}

\subsubsection{Модель TCP/IP}
Модель TCP/IP — это практическая четырехуровневая модель стека протоколов, на основе которой функционирует современный Интернет.~\cite{rfc1180}
В отличие от теоретической модели OSI, TCP/IP описывает реальный набор протоколов, обеспечивающих передачу данных между устройствами в глобальных сетях.

Четыре уровня модели TCP/IP:
\begin{itemize}
    \item \textbf{Прикладной уровень (Application Layer)}: Объединяет функции верхних уровней OSI (прикладного, представления, сеансового). Предоставляет протоколы, с которыми работают пользовательские приложения (например, HTTP, SMTP, DNS).
    \item \textbf{Транспортный уровень (Transport Layer)}: Аналогичен транспортному уровню OSI. Обеспечивает сквозную передачу данных между хостами с помощью протоколов TCP (надежная доставка) и UDP (быстрая доставка).
    \item \textbf{Сетевой (межсетевой) уровень (Internet Layer)}: Соответствует сетевому уровню OSI. Отвечает за маршрутизацию пакетов между сетями с помощью IP (Internet Protocol) и логической адресации.
    \item \textbf{Канальный уровень (Link Layer)}: Совмещает в себе функции физического и канального уровней OSI. Отвечает за передачу данных в пределах одного сегмента сети (например, через Ethernet или Wi-Fi).
\end{itemize}

\input{src/embeds/tikz/02_tcp_ip_model}

\subsection{Теоретические основы}

\subsubsection{Сетевой стек операционной системы Linux}
Для понимания того, как виртуальный криптографический интерфейс встраивается в операционную систему, необходимо сначала рассмотреть архитектуру ее сетевой подсистемы.
Сетевой стек Linux основан на практической модели TCP/IP, которая, в свою очередь, является реализацией принципов, заложенных в более общей семиуровневой эталонной модели OSI. \\

\nlparagraph{Процесс передачи данных: инкапсуляция и декапсуляция}

Ключевым принципом работы любого сетевого стека является поуровневая обработка данных.

\begin{itemize}
    \item \textbf{Инкапсуляция}: Происходит во время отправки данных, когда данные спускаются вниз по уровню стека. При этом каждый последующий уровень добавляет служебную информацию в виде заголовка пакета.
    \item \textbf{Декапсуляция}: Происходит во время получения данных, по сути происходит процесс обратный инкапсуляции, когда каждый уровень удаляет свой заголовок и передает данные вверх по уровню стека.
\end{itemize}

\input{src/embeds/tikz/06_network_stack}

Рассмотрим подробнее уровни сетевого стека Linux в соответствии с моделью TCP/IP.

\nlparagraph{Прикладной уровень}

Это самый верхний уровень, с которым напрямую взаимодействуют пользовательские приложения, такие как веб-браузеры, почтовые клиенты или мессенджеры.
Протоколы этого уровня (HTTP, FTP, SMTP, DNS) определяют формат сообщений, которыми обмениваются программы.
С точки зрения ядра, данные на этом уровне — это просто поток байтов, который приложение передает сетевому стеку для отправки. \\

\nlparagraph{Транспортный уровень}
Основная задача этого уровня — обеспечить связь между конкретными процессами (программами) на хосте-отправителе и хосте-получателе.
В Linux он представлен в основном двумя протоколами: TCP и UDP.\\

На этом уровне происходит добавление заголовков TCP или UDP, которые содержат, в частности, номера портов источника и назначения.

\nlparagraph{Сетевой уровень}
Этот уровень отвечает за глобальную адресацию и маршрутизацию данных через несколько сетей.
Ключевым протоколом здесь является IP.
Он принимает сегменты или дейтаграммы от транспортного уровня, добавляет к ним свой заголовок с IP-адресами источника и получателя и формирует структуру, называемую пакетом.
Задача IP — доставить пакет до целевого хоста, но он не гарантирует надежность.
За надежность, если она нужна, отвечает вышестоящий транспортный уровень.

\nlparagraph{Канальный уровень}

Это самый нижний уровень стека, который отвечает за передачу данных в пределах одного физического сегмента сети.
Он берет IP-пакет с сетевого уровня, добавляет свой заголовок и, возможно, окончаение с контрольной суммой, формируя кадр.
Именно в виде кадров данные передаются по физической среде (витой паре, оптоволокну, радиосигналу).
Этот уровень также отвечает за преобразование IP-адресов в физические MAC-адреса с помощью протокола ARP.\\

Таким образом, сетевой стек Linux представляет собой четко структурированную систему, где каждый уровень выполняет свою задачу.
Виртуальный сетевой интерфейс, в том числе криптографический, встраивается в эту модель, как правило, на границе между сетевым и канальным уровнями, позволяя перехватывать IP-пакеты перед их отправкой в физическую сеть для дальнейшей обработки (шифрования).

\subsubsection{Классификация виртуальных частных сетей}
На данный момент существует несколько классификаций VPN-технологий. Наиболее распространенными являются классификации по уровню модели OSI.

\nlparagraph{Классификация по уровню модели OSI}
Одним из ключевых подходов к классификации VPN-технологий является их разделение в зависимости от уровня эталонной модели OSI, на котором они функционируют. Данный критерий определяет, какой тип данных инкапсулируется в защищенный туннель и как технология взаимодействует с сетевой инфраструктурой.

\begin{itemize}
    \item \textbf{Канальный уровень (Layer 2):}
    Протоколы этого уровня эмулируют прямое физическое соединение между узлами, создавая единый широковещательный домен. Они оперируют кадрами (frames), а не IP-пакетами, что позволяет передавать поверх них трафик не только IP, но и других сетевых протоколов (например, IPX, AppleTalk).
    \begin{itemize}
        \item \textit{PPP (Point-to-Point Protocol):} Базовый протокол для установления прямого соединения между двумя узлами. Сам по себе не является VPN-протоколом, но служит основой для многих из них.
        \item \textit{PPTP (Point-to-Point Tunneling Protocol):} Разработанный компанией Microsoft протокол, который инкапсулирует PPP-кадры. Отличается высокой скоростью и простотой настройки, однако на сегодняшний день считается устаревшим и небезопасным из-за наличия ряда критических уязвимостей.
        \item \textit{L2F (Layer 2 Forwarding Protocol):} Протокол, разработанный компанией Cisco и являющийся предшественником L2TP. В настоящее время практически не используется.
        \item \textit{L2TP (Layer 2 Tunneling Protocol):} Стандартизированный протокол, созданный как результат объединения идей PPTP и L2F. Важно отметить, что L2TP сам по себе не обеспечивает шифрование трафика, а лишь создает туннель. Для обеспечения конфиденциальности и целостности данных его практически всегда используют в связке с набором протоколов IPSec.
        \item \textit{MPLS (Multiprotocol Label Switching):} Технология, широко применяемая операторами связи для построения клиентских VPN. MPLS работает путем присвоения пакетам специальных меток, на основе которых происходит их коммутация. Это обеспечивает изоляцию трафика разных клиентов в сети провайдера, но не предполагает криптографической защиты передаваемых данных по умолчанию.
    \end{itemize}

    \item \textbf{Сетевой уровень (Layer 3):}
    Технологии этого уровня оперируют IP-пакетами. Они создают виртуальную сеть поверх существующей IP-инфраструктуры, обеспечивая маршрутизацию между удаленными сетями или узлами.
    \begin{itemize}
        \item \textit{IPSec (Internet Protocol Security):} Представляет собой набор протоколов для защиты IP-трафика. IPSec может обеспечивать аутентификацию, целостность и шифрование каждого IP-пакета в потоке данных. Является одним из наиболее распространенных и надежных стандартов для построения VPN типа "сеть-сеть" и для организации удаленного доступа.
        \item \textit{WireGuard:} Современный VPN-протокол, также функционирующий на сетевом уровне и использующий UDP в качестве транспортного протокола. Его отличительной чертой является применение криптографического рукопожатия на основе Noise Protocol Framework, что обеспечивает взаимную аутентификацию сторон, согласование сеансовых ключей и прямую секретность (forward secrecy). Непосредственно инкапсулируемый трафик защищается с помощью аутентифицированного шифрования с присоединенными данными (AEAD).
    \end{itemize}

    \item \textbf{Транспортный и более высокие уровни (Layer 4+):}
    Данные решения работают на уровнях выше сетевого, часто встраиваясь между транспортным и прикладным уровнями. Они создают защищенные соединения для конкретных приложений или сеансов связи.
    \begin{itemize}
        \item \textit{SSL/TLS (Secure Sockets Layer/Transport Layer Security):} SSL является предшественником более современного и безопасного протокола TLS. Изначально эти протоколы были разработаны для защиты веб-трафика (HTTPS). VPN-решения на их основе (SSL VPN) часто предоставляют доступ к корпоративным ресурсам через веб-браузер, что упрощает подключение для удаленных пользователей.
        \item \textit{GRE (Generic Routing Encapsulation):} Протокол, позволяющий инкапсулировать пакеты одного протокола в пакеты другого (как правило, IP). Подобно L2TP, GRE не предоставляет функций шифрования и для построения защищенного канала часто используется совместно с IPSec.
    \end{itemize}
\end{itemize}

\nlparagraph{Классификация по уровню безопасности}
Помимо классификации по уровню модели OSI, VPN-технологии принято разделять по степени обеспечиваемой ими безопасности, что напрямую зависит от используемых криптографических алгоритмов и архитектуры протокола.

\begin{itemize}
    \item \textbf{Высокий уровень безопасности:} К этой категории относятся современные решения, использующие стойкие криптографические алгоритмы (например, AES, SHA-2) и надежные механизмы аутентификации.
    \begin{itemize}
        \item \textit{IPSec} (при условии использования современных криптографических наборов).
        \item \textit{L2TP/IPSec}, где безопасность целиком обеспечивается за счет IPSec.
        \item VPN на основе \textit{TLS} (например, OpenVPN), который является современным отраслевым стандартом.
        \item \textit{WireGuard}, который по своей архитектуре и выбору криптографических примитивов относится к наиболее современным и защищенным решениям.
    \end{itemize}

    \item \textbf{Средний уровень безопасности:} Протоколы, которые обеспечивают в первую очередь изоляцию трафика, а не его криптографическую защиту от перехвата.
    \begin{itemize}
        \item \textit{MPLS}, который гарантирует, что трафик одного VPN не попадет в другой VPN в рамках сети одного оператора, но не защищает его от анализа самим оператором или от атак на его магистральную сеть.
    \end{itemize}

    \item \textbf{Низкий уровень или устаревшие протоколы:} К этой группе относятся протоколы с общеизвестными уязвимостями или те, что не имеют встроенных средств безопасности. Их использование в современных системах не рекомендуется.
    \begin{itemize}
        \item \textit{PPTP}, который был скомпрометирован и имеет ряд серьезных недостатков в архитектуре безопасности.
        \item \textit{L2F}, как устаревший и вытесненный более совершенными технологиями.
    \end{itemize}
\end{itemize}

\subsubsection{Краткий анализ работы WireGuard}
WireGuard представляет собой современный VPN-протокол, разработанный с акцентом на простоту, для которого характерен высокий уровень производительности и криптографической надежности.
В отличие от громоздких предшественников, таких как IPSec или OpenVPN, WireGuard имеет значительно меньшую кодовую базу, что упрощает аудит безопасности и значительно сокращает эвентульную поверхность атак.
Протокол функционирует на сетевом уровне (Layer 3) модели OSI и использует UDP для передачи данных.~\cite{wireguard}\\

В основе работы WireGuard лежит несколько ключевых концепций и механизмов, которые отличают его от других VPN-решений.

\nlparagraph{Идентификация и архитектура}
WireGuard отходит от традиционной модели "клиент-сервер".
В его архитектуре все участники сети являются равноправными узлами (peers).
Идентификация каждого узла происходит не по логину и паролю, а исключительно по статическому 32-байтовому открытому ключу, основанному на эллиптической кривой Curve25519.\\

Ключевой особенностью является "криптографическая молчаливость": узел WireGuard не отвечает ни на какие пакеты, приходящие от неизвестных ему узлов.
Если пакет не может быть аутентифицирован с помощью известного открытого ключа, он просто отбрасывается без отправки какого-либо ответа.
Это делает сканирование портов для обнаружения WireGuard-серверов практически невозможным без знания открытых ключей.\\

\nlparagraph{Установление сеанса и обмен ключами}
Процесс установления соединения (handshake) в WireGuard построен на базе фреймворка Noise Protocol Framework, а конкретно — на шаблоне IKpsk2.\\

Этот выбор обеспечивает:
\begin{itemize}
    \item \textbf{Взаимную аутентификацию}: Оба узла уверены в личности друг друга.
    \item \textbf{Согласование ключей}: На основе обмена сообщениями вырабатываются сеансовые ключи для шифрования трафика.
    \item \textbf{Прямую секретность (Forward Secrecy)}: Для каждого сеанса генерируется новая пара эфемерных (временных) ключей.
    Компрометация статических ключей узла не позволит расшифровать перехваченный ранее трафик, так как эфемерные ключи, использованные для генерации сеансовых ключей, уничтожаются после завершения рукопожатия.
\end{itemize}

Само рукопожатие происходит за 1.5 RTT (Round-Trip Time).
Узел, инициирующий соединение (инициатор), отправляет сообщение \textit{Handshake Initiation}.
Узел-ответчик (респондер) отвечает сообщением \textit{Handshake Response}.
После получения ответа инициатор может сразу же начать передачу зашифрованных данных. Респондер же, в свою очередь, сможет отправлять данные только после того, как получит первый пакет данных от инициатора, что служит неявным подтверждением успешного завершения рукопожатия и защищает от атак повторного воспроизведения (replay attacks).

\nlparagraph{Шифрование трафика и ротация ключей}
Для шифрования инкапсулированных IP-пакетов используется современная и высокопроизводительная схема аутентифицированного шифрования с присоединенными данными (AEAD) ChaCha20-Poly1305.
Эта конструкция одновременно обеспечивает конфиденциальность (шифрование) и целостность/аутентичность (имитозащиту) данных.\\

Протокол предусматривает автоматическую ротацию сеансовых ключей.
Новое рукопожатие и, соответственно, генерация новых ключей происходит периодически (например, каждые две минуты), а также после передачи определенного объема данных.
Это ограничивает количество данных, зашифрованных одним ключом, и минимизирует последствия в случае его возможной компрометации.

\nlparagraph{Маршрутизация на основе криптоключей (Cryptokey Routing)}
Одной из фундаментальных идей WireGuard является концепция \textit{Cryptokey Routing}.
Суть ее заключается в жесткой привязке открытого ключа узла к списку IP-адресов, трафик для которых разрешено принимать от этого узла или отправлять на него.

Эта политика реализуется через параметр \texttt{AllowedIPs} для каждого узла:
\begin{itemize}
    \item \textbf{На входе}: Когда WireGuard-интерфейс получает зашифрованный пакет, он расшифровывает его и проверяет подлинность.
    Затем он смотрит на исходный IP-адрес в расшифрованном внутреннем пакете.
    Если этот IP-адрес не входит в список \texttt{AllowedIPs} для ключа, с помощью которого был аутентифицирован пакет, пакет отбрасывается.
    \item \textbf{На выходе}: Когда операционная система направляет пакет в WireGuard-интерфейс, WireGuard ищет узел, в конфигурации \texttt{AllowedIPs} которого содержится IP-адрес назначения этого пакета.
    Пакет шифруется соответствующим ключом и отправляется этому узлу.
\end{itemize}

Такой подход устраняет необходимость в сложных правилах маршрутизации внутри VPN и делает конфигурацию более простой и предсказуемой.

\nlparagraph{Защита от атак}
Протокол включает механизмы защиты от распространенных атак:
\begin{itemize}
    \item \textbf{Защита от DoS-атак}: Чтобы предотвратить атаки на исчерпание ресурсов, требующих дорогостоящих криптографических вычислений на этапе рукопожатия, WireGuard использует механизм cookie.
    Если узел находится под высокой нагрузкой, в ответ на \textit{Handshake Initiation} он может отправить не полноценный ответ, а небольшое сообщение с "cookie".
    Инициатор должен будет включить этот cookie в свое следующее сообщение, что подтвердит подлинность его IP-адреса без выполнения сложных вычислений на стороне ответчика.
    \item \textbf{Защита от атак повтора (Replay Attacks)}: Для сообщений рукопожатия используется метка времени с наносекундной точностью, а для пакетов данных — монотонно возрастающий счетчик-nonce.
    Узел отбрасывает пакеты с уже виденными или более старыми значениями.
    \item \textbf{Отсутствие криптографической гибкости (Cryptographic Agility)}: WireGuard намеренно использует фиксированный набор криптографических алгоритмов.
    Это является его преимуществом, так как исключает целый класс атак на понижение стойкости (downgrade attacks), когда злоумышленник заставляет стороны согласовать использование устаревшего и уязвимого алгоритма.
    Если в будущем какой-либо из используемых алгоритмов будет скомпрометирован, потребуется обновление версии самого протокола.
\end{itemize}

\subsubsection{Криптографическая подсистема ядра Linux}
Для реализации криптографических функций в ядре Linux существует специальный фреймворк — Crypto API.~\cite{crypto_api_doc}
Он представляет собой интерфейс, который позволяет другим подсистемам ядра (например, сетевому стеку или файловым системам) и модулям использовать криптографические алгоритмы, не вникая в детали их реализации.
Основная задача Crypto API — предоставить стабильный и расширяемый набор криптографических примитивов.

\nlparagraph{Архитектура и основные понятия}
Crypto API рассматривает все алгоритмы как «преобразования» (transformations).
Дескриптор, с которым работает пользователь API, обычно называется tfm (transformation object).\\

Ключевые типы алгоритмов, поддерживаемые фреймворком:
\begin{itemize}
    \item \textbf{Симметричные шифры (skcipher)}
    \item \textbf{AEAD-шифры (aead)}
    \item \textbf{Хэш-функции (shash, ahash)}
    \item \textbf{Генераторы псевдослучайных чисел (rng)}
\end{itemize}

Одной из основных идей Crypto API является использование шаблонов (templates).
Шаблон — это реализация определённого режима работы или протокола, которая использует другой, более простой алгоритм в качестве основы. \\

Например, алгоритм cbc(aes) представляет собой шаблон cbc (режим сцепления блоков шифротекста), который работает поверх блочного шифра aes. \\

Аналогично, hmac(sha256) — это шаблон hmac, использующий хэш-функцию sha256. Такой подход позволяет комбинировать алгоритмы, не создавая для каждой комбинации отдельную реализацию.

\nlparagraph{Режимы работы: синхронный и асинхронный}
Crypto API поддерживает два режима вызова операций:
\begin{itemize}
    \item \textbf{Синхронный}:
    Вызов блокирует выполнение до тех пор, пока криптографическая операция не будет завершена.
    \item \textbf{Асинхронный}:
    Вызов немедленно возвращает управление, а сама операция выполняется в фоновом режиме.
    По завершении операции ядро вызывает специальную callback-функцию, переданную при инициализации
\end{itemize}

\nlparagraph{Управление алгоритмами}
Все доступные в системе криптографические алгоритмы можно посмотреть в файле \textit{/proc/crypto}.
Для каждого алгоритма указывается его имя, драйвер, приоритет, тип и другие параметры.\\

\input{src/embeds/console/03_proc_crypto}

Когда модуль ядра запрашивает алгоритм по общему имени (например, "aes"), Crypto API выбирает реализацию с самым высоким приоритетом.
Это позволяет системе автоматически использовать наиболее эффективную реализацию — например, аппаратное ускорение AES-NI на процессорах Intel вместо универсальной реализации на языке C.\\

Поддержку нового алгоритма можно добавить, создав модуль ядра, который регистрирует свою реализацию через функцию \mintinline{c}{crypto_register_alg()}.
Это делает Crypto API расширяемым и позволяет легко интегрировать новые криптографические стандарты, что является ключевой задачей в данной работе.
Это означает, что мы можем реализовать поддержку ГОСТ-алгоритмов и зарегистрировать их в системе, после чего они станут доступны для использования в нашем виртуальном сетевом интерфейсе.

\subsubsection{Протокол Netlink}
Для того чтобы разработанный в ядре криптографический интерфейс можно было настраивать и контролировать, необходим надежный канал связи между пространством ядра (kernel space) и пространством пользователя (user space).
Исторически для этих целей использовался системный вызов \mintinline{c}{ioctl()}, однако он обладает существенными недостатками, главные из которых — необходимость использовать структуры данных фиксированного размера и сложность расширения API без нарушения обратной совместимости. \\

Современным и гораздо более гибким решением этой задачи является протокол Netlink.
Netlink — это механизм межпроцессного взаимодействия (IPC), реализованный в виде семейства сокетов (\mintinline{c}{AF_NETLINK}), предназначенный специально для коммуникации между ядром и процессами в пространстве пользователя.~\cite{netlink_doc} \\

\nlparagraph{Принципы работы Netlink}
Взаимодействие через Netlink строится на обмене сообщениями через сокеты.
С точки зрения пользовательского приложения, процесс выглядит следующим образом:
\begin{enumerate}
    \item Создается сокет типа \mintinline{c}{AF_NETLINK}.
    \item Формируется сообщение-запрос и отправляет его в ядро с помощью системного вызова \mintinline{c}{send()}.
    \item Ядро обрабатывает запрос и отправляет ответ, который приложение считывает с помощью вызова \mintinline{c}{recv()}.
\end{enumerate}

Такой подход позволяет организовать двунаправленный обмен данными.
Netlink поддерживает два основных типа запросов:
\begin{itemize}
    \item \textbf{Одиночный запрос (do)}:
    Выполнение одной конкретной операции.
    Приложение отправляет один запрос и получает в ответ сообщение с результатом операции \mintinline{c}{NLMSG_ERROR} или запрошенные данные.
    \item \textbf{Запрос на дамп (dump)}:
    Получение списка объектов.
    Приложение отправляет один запрос с флагом \mintinline{c}{NLM_F_DUMP}, а в ответ ядро присылает серию сообщений, по одному на каждый объект, и в конце — специальное сообщение \mintinline{c}{NLMSG_DONE}, сигнализирующее о завершении передачи
\end{itemize}

\nlparagraph{Структура сообщения Netlink}
В отличии от \mintinline{c}{ioctl()}, Netlink является куда более гибким.
Каждое сообщение состоит из заголовка \mintinline{c}{nlmsghdr} и полезной нагрузки.

\input{src/embeds/code/04_nl_message_header}

Полезная нагрузка сообщения состоит из набора атрибутов в формате TLV (Type-Length-Value).
Каждый атрибут — это самодостаточный блок данных, содержащий свой тип, длину и значение. Такой подход позволяет легко добавлять новые параметры, не ломая старые версии API.

\nlparagraph{Generic Netlink}
Изначально Netlink использовал статически определенные идентификаторы для каждой подсистемы ядра (например, \mintinline{c}{NETLINK_ROUTE} для сетевых настроек).
Этот подход, называемый "Classic Netlink", был не очень масштабируемым.\\

Ему на смену пришел Generic Netlink (\mintinline{c}{NETLINK_GENERIC}).
Это своего рода мультиплексор, который позволяет множеству подсистем ядра динамически регистрировать свои «семейства» (families) и команды.
Каждое семейство получает свой уникальный ID во время работы системы.
Generic Netlink также предоставляет механизмы интроспекции, позволяя пользовательскому приложению запросить у ядра информацию о том, какие семейства зарегистрированы и какие команды и атрибуты они поддерживают.\\

Чтобы лучше понять, как работает Generic Netlink, рассмотрим структуру его сообщений.
Структура напоминает стекирование сетевых протоколов: общий заголовок Netlink инкапсулирует в себе заголовок Generic Netlink, за которым уже следуют данные (атрибуты) конкретного семейства.\\

Каждое сообщение начинается со стандартной структуры nlmsghdr, за которой сразу следует специфичная для Generic Netlink структура \mintinline{c}{genlmsghdr}.

\input{src/embeds/code/05_ge_nl_message_header}

Ключевое отличие Generic Netlink от его классического предшественника заключается в использовании поля \mintinline{c}{nlmsg_type}.
Если раньше оно содержало код конкретной операции (например, «получить информацию об интерфейсе»), то теперь оно хранит динамически назначаемый ID семейства (Family ID).
Таким образом, это поле используется для маршрутизации сообщения к нужной подсистеме ядра. \\

Сама же команда, которую нужно выполнить, теперь указывается в поле cmd вложенной структуры \mintinline{c}{genlmsghdr}. \\

Помимо запросов типа «do» и «dump», инициируемых пользователем, Generic Netlink поддерживает и асинхронные уведомления (multicast).
Это однонаправленная коммуникация от ядра к пользователю для оповещения о событиях. Для получения таких уведомлений приложение должно подписаться на соответствующую multicast-группу. \\
