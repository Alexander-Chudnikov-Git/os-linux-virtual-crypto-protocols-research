\section{Аналитическая часть}

\subsection{Анализ алгоритма создания модулей ядра Linux}

Одним из ключевых механизмов расширения функциональности ядра Linux, не требующим его полной перекомпиляции, является использование загружаемых модулей ядра (Loadable Kernel Modules, LKM). ~\cite{kernel_modules_doc}
Этот подход позволяет динамически подключать и отключать код в работающей системе, что является основой для большинства драйверов устройств, файловых систем и сетевых протоколов.
Анализ данного механизма включает в себя рассмотрение структуры модуля, процесса его жизненного цикла, сборки и методов отладки.

\subsubsection{Концепция и структура модуля ядра}

Модуль ядра представляет собой скомпилированный объектный файл (.ko — kernel object), содержащий код, который может быть загружен в ядро и связан с ним во время выполнения.
Это решает проблему недостаточной гибкости монолитных ядер, добавляя модульность и расширяемость.\\

Каждый модуль имеет как минимум две основные функции, определяющие его жизненный цикл:
\begin{itemize}
    \item \textbf{Функция инициализации}: Вызывается при загрузке модуля в ядро.
    Она отвечает за регистрацию функциональности, которую предоставляет модуль.
    \item \textbf{Функция завершения}: Вызывается при выгрузке модуля.
    Её задача — освободить все ресурсы, захваченные модулем, и отменить регистрацию своей функциональности.
\end{itemize}

Эти функции регистрируются в ядре с помощью макросов \mintinline{c}{module_init()} и \mintinline{c}{module_exit()}.

\input{src/embeds/code/07_kernel_module_example}

Сообщения, генерируемые ядром с помощью printk или его производных, не выводятся напрямую на стандартный вывод, а попадают в кольцевой буфер ядра.
Их можно просмотреть с помощью утилиты dmesg или в системных логах (например, /var/log/syslog).

\subsubsection{Процесс сборки модуля ядра}
Сборка модуля ядра кардинально отличается от сборки пользовательских приложений.
Она должна производиться с использованием заголовочных файлов и конфигурации именно того ядра, в которое модуль будет загружаться.
Для этого используется система сборки ядра kbuild. Процесс управляется двумя основными файлами:

\begin{itemize}
    \item \textbf{Файл Makefile}: Запускает систему сборки ядра, указывая на каталог с исходным кодом модуля.
    \input{src/embeds/code/08_kernel_makefile_example}
    \item \textbf{Файл Kbuild}: Содержит конкретные инструкции для kbuild о том, какие файлы и как компилировать.
    \input{src/embeds/code/09_kernel_kbuild_example}
\end{itemize}

Суффиксы в файле Kbuild определяют, как будет скомпилирован объект:
\begin{itemize}
    \item \mintinline{c}{obj-m}: Объект будет скомпилирован как загружаемый модуль (.ko).
    \item \mintinline{c}{obj-y}: Объект будет скомпилирован и статически встроен в образ ядра.
\end{itemize}

\subsubsection{Загрузка и выгрузка модуля}
Управление модулями осуществляется с помощью следующих утилит:
\begin{itemize}
    \item \mintinline{bash}{insmod <путь_к_файлу.ko>}: Загружает модуль в ядро. При этом выполняется его \mintinline{c}{init} функция.
    \item \mintinline{bash}{rmmod <имя_модуля>}: Выгружает модуль из ядра. При этом выполняется \mintinline{c}{exit} функция.
    \item \mintinline{bash}{lsmod}: Показывает список всех загруженных в данный момент модулей.
\end{itemize}

Информацию о загруженных модулях также можно посмотреть в \mintinline{bash}{/proc/modules} и \mintinline{bash}{/sys/module}.

\subsubsection{Методы отладки модулей ядра}
Отладка кода, работающего в пространстве ядра, является сложной задачей, поскольку любая критическая ошибка (например, разыменование NULL-указателя) может привести к полной остановке системы — состоянию Kernel Panic.

\begin{itemize}
    \item \textbf{Анализ \texttt{Kernel Oops}}: <<Oops>> --- это сообщение о некритической ошибке в ядре. В отличие от \texttt{Panic}, система пытается продолжить работу, но её состояние уже нестабильно. Сообщение об \texttt{Oops} содержит ключевую информацию для отладки:
    \begin{itemize}
        \item Причина ошибки (\texttt{BUG: unable to handle kernel paging request}).
        \item Адрес инструкции, вызвавшей сбой, и смещение внутри функции (\texttt{EIP is at my\_oops\_init+0x5/0x20}).
        \item Код ошибки, который описывает тип операции (чтение/запись, режим ядра/пользователя).
        \item Состояние регистров и трассировку стека вызовов (\texttt{Call Trace}).
    \end{itemize}

    \item \textbf{Использование \texttt{objdump} и \texttt{addr2line}}: Имея адрес инструкции из сообщения \texttt{Oops} и базовый адрес загрузки модуля (из \texttt{/proc/modules}), можно точно определить строку в исходном коде, которая привела к сбою.
    \begin{itemize}
        \item \texttt{objdump -dS --adjust-vma=<базовый\_адрес> module.ko}: Дизассемблирует код модуля, сопоставляя его с исходным кодом.
        \begin{minted}{bash}
objdump -dS --adjust-vma=<базовый_адрес> module.ko
        \end{minted}
        \item \texttt{addr2line -e module.o <смещение>}: Преобразует смещение адреса внутри функции в номер строки исходного кода.
        \begin{minted}{bash}
addr2line -e module.o <смещение>
        \end{minted}
    \end{itemize}

    \item \textbf{Отладка с помощью \texttt{printk}}: Самый простой и распространенный способ --- вставка отладочных сообщений в код. \texttt{printk} позволяет указывать уровень важности сообщения (например, \texttt{KERN\_INFO}, \texttt{KERN\_DEBUG}). Уровнем вывода сообщений на консоль можно управлять через \texttt{/proc/sys/kernel/printk}. Для удобства трассировки часто используются предопределенные макросы \texttt{\_\_FILE\_\_}, \texttt{\_\_LINE\_\_} и \texttt{\_\_func\_\_}.

    \item \textbf{Динамическая отладка (\texttt{dyndbg})}: Более гибкий механизм, позволяющий включать и выключать отладочные сообщения (\texttt{pr\_debug()}) на лету, без перекомпиляции модуля. Для этого ядро должно быть собрано с опцией \texttt{CONFIG\_DYNAMIC\_DEBUG}. Управление осуществляется через запись в файл \texttt{/sys/kernel/debug/dynamic\_debug/control}, позволяя фильтровать сообщения по имени файла, функции, номеру строки или формату сообщения.

    \item \textbf{Отладчик ядра (\texttt{KDB/KGDB})}: Для сложной отладки можно использовать встроенный отладчик ядра \texttt{KDB}. Он позволяет останавливать выполнение ядра, устанавливать точки останова (\texttt{breakpoints}), просматривать и изменять содержимое памяти и регистров в <<живой>> системе, обычно через последовательный порт.
\end{itemize}


\subsection{Анализ криптографической подсистемы ядра Linux}

Как было упомянуто ранее, добавление нового криптографического алгоритма в ядро осуществляется путем создания модуля, который регистрирует реализацию через функции Crypto API.
Этот процесс является стандартизированным и основан на заполнении специальных структур данных, которые описывают свойства и предоставляют указатели на функции самого алгоритма.

\subsubsection{Регистрация нового алгоритма в ядре}

Процесс интеграции нового алгоритма в ядро завершается его регистрацией в Crypto API.
Для этого используется набор специализированных функций, выбор которых зависит от типа реализуемого преобразования.
Например, для регистрации асинхронных симметричных шифров используется \mintinline{c}{crypto_register_skcipher()}, для асинхронных хэш-функций — \mintinline{c}{crypto_register_ahash()}, для синхронных — \mintinline{c}{crypto_register_shash()}, а \mintinline{c}{crypto_register_alg()} служит для регистрации более общих или базовых типов.
Независимо от выбранной функции, основная информация об алгоритме передается через унифицированную структуру struct \mintinline{c}{crypto_alg} (или расширяющую ее структуру, как, например, struct \mintinline{c}{skcipher_alg}).
Ключевые поля этой структуры:
\input{src/embeds/code/00_crypto_alg_struct}

\subsubsection{Пример реализации: базовый блочный шифр}
Для демонстрации процесса рассмотрим реализацию простого алгоритма шифрования на основе операции XOR.

\nlparagraph{Определение контекста и функции установки ключа}

Контекст (ctx) — это структура для хранения состояния алгоритма, в данном случае — только ключа шифрования.
Функция \mintinline{c}{setkey()} проверяет длину ключа и сохраняет его в контексте.

\input{src/embeds/code/01_crypto_bc_ctx}

\nlparagraph{Реализация функции шифрования}
Поскольку операция XOR обратима, одна и та же функция будет использоваться и для шифрования, и для расшифрования

\input{src/embeds/code/02_crypto_bc_enc}

\nlparagraph{Регистрация алгоритма}
Все части собираются воедино в структуре \mintinline{c}{crypto_alg}, которая затем регистрируется в ядре при загрузке модуля.

\input{src/embeds/code/03_crypto_bc_reg}

После загрузки такого модуля в ядре появится новый алгоритм \mintinline{c}{xor-cipher}, который можно будет использовать с любым стандартным шаблоном, например, запросив \mintinline{c}{cbc(xor-cipher)}.

\subsubsection{Пример реализации: полноценный режим шифрования}

Как отмечалось ранее, стандартные шаблоны могут не подходить для реализации отечественных стандартов.
Кроме того, они могут не поддерживать обработку данных, длина которых не кратна размеру блока.
В таких случаях необходимо реализовать полноценный режим, используя Symmetric Key Cipher API.

\nlparagraph{Работа с данными}
Ключевое отличие SKCIPHER API — работа с данными через \mintinline{c}{scatterlist}, что позволяет обрабатывать фрагментированные в памяти пакеты без их копирования. Для итерации по таким данным используется вспомогательная структура \mintinline{c}{skcipher_walk}.

\nlparagraph{Реализация функции шифрования в режиме CBC}
Функция шифрования принимает структуру \mintinline{c}{skcipher_request}, содержащий все необходимые данные.
Цикл \mintinline{c}{while (walk.nbytes > 0)} обходит все непрерывные участки данных, позволяя применить к ним криптографическое преобразование.

\input{src/embeds/code/10_crypto_sk_ctx}

\nlparagraph{Регистрация SKCIPHER алгоритма}
Процесс схож с регистрацией блочного шифра, но используется структура \mintinline{c}{skcipher_alg} и функция \mintinline{c}{crypto_register_skcipher()}.

\input{src/embeds/code/11_crypto_sk_reg}